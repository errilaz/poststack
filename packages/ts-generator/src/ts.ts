import type { SchemaData, AttributeData, FuncData } from "@poststack/metadata";

export default async function generateCode(schema: SchemaData): Promise<string> {
  const now = new Date();
  return ts`// GENERATED BY POSTSTACK
// AT ${now.toLocaleDateString()} ${now.toLocaleTimeString()}
import { SchemaData, EnumData, TableData, TypeData } from "poststack"

// Base
export const Schema: SchemaData = {
  enums: [],
  types: [],
  tables: [],
  functions: []
};

// Enums
${schema.enums.map(e => ts`
export enum ${e.tsName} {
  ${e.fields.sort(f => f.order).map(f => f.name).join(",\n  ")}
  
}
export const ${e.tsName}Type: EnumData = {
  name: "${e.name}",
  tsName: "${e.tsName}",
  fields: [${e.fields.sort(f => f.order).map(f => ts`
    { name: "${f.name}",
      order: ${f.order}
    },`).join("\n  ")}
  ],
};
Schema.enums.push(${e.tsName}Type);
`).join("\n")}
// Types
${schema.types.map(t => ts`
export interface ${t.tsName} {
  ${t.attributes.sort(a => a.order).map(a => ts`${a.name}: ${generateTsType(a.tsType as string[])};`)
      .join("\n  ")}
}
export const ${t.tsName}: TypeData = {
  name: "${t.name}",
  tsName: "${t.tsName}",
  attributes: [${t.attributes.sort(a => a.order).map(generateAttributeMetadata).join(",\n")}],
};
Schema.types.push(${t.tsName});
`).join("\n")}
// Tables
${schema.tables.map(t => ts`
export interface ${t.tsName} {
  ${t.columns.sort(a => a.order).map(a => ts`${a.name}: ${generateTsType(a.tsType as string[])};`)
          .join("\n  ")}
}
export const ${t.tsName}: TableData = {
  name: "${t.name}",
  tsName: "${t.tsName}",
  columns: [${t.columns.sort(a => a.order).map(generateAttributeMetadata).join(",\n")}],
};
Schema.tables.push(${t.tsName});
`).join("\n")}
// Functions
${schema.functions.map(f => ts`
export type ${f.name} = ${generateFunctionSignature(f)};
export const ${f.name}: FuncData = {
  name: "${f.name}",
  returnType: ${generateTsTypeMetadata(f.returnType as string[])},
  parameters: [${f.parameters.sort(p => p.order).map(generateAttributeMetadata).join(",\n")}]
}
Schema.functions.push(${f.name});
`).join("\n")}
export interface Tables {
${schema.tables.map(t =>
            `  ${t.name}: ${t.tsName}`).join(";\n")}
}

export interface Functions {
${schema.functions.map(f =>
              `  ${f.name}: ${generateFunctionSignature(f)}`).join(";\n")}
}

export interface Api {
  tables: Tables;
  functions: Functions;
  schema: Schema;
}

// This is to avoid a type parameter.
export const Api: Api = {
  tables: undefined as unknown as Tables,
  functions: undefined as unknown as Functions,
  schema: Schema
};

export default Api;
`;
}

function generateFunctionSignature(f: FuncData) {
  return "(" + f.parameters.map(p =>
    `${p.name}: ${generateTsType(p.tsType as string[])}`
  ).join(", ") + `) => Promise<${generateTsType(f.returnType as string[])}>`
}

function generateAttributeMetadata({ name, order, nullable, tsType }: AttributeData) {
  return ts`
    { name: "${name}",
      order: ${order},
      nullable: ${nullable},
      tsType: ${generateTsTypeMetadata(tsType as string[])}
    }`;
}

function generateTsTypeMetadata(tsType: string[]): string {
  if (tsType[0] === "interface") {
    return `["interface", ${tsType[1]}]`;
  }
  else if (tsType[0] === "enum") {
    return `["enum", ${tsType[1]}Type]`;
  }
  else if (tsType[0] === "array") {
    return `["array", ${generateTsTypeMetadata(tsType[1] as unknown as string[])}]`;
  }
  return `"${tsType}"` as unknown as string;
}

function generateTsType(tsType: string[]): string {
  if (tsType[0] === "array") {
    return generateTsType(tsType[1] as unknown as string[]) + "[]";
  }
  if (Array.isArray(tsType)) {
    return tsType[1];
  }
  return tsType as unknown as string;
}

function ts(literals: TemplateStringsArray, ...placeholders: (string | number | boolean)[]) {
  let s = "";
  for (let i = 0; i < placeholders.length; i++) {
    s += literals[i];
    s += placeholders[i];
  }
  s += literals[literals.length - 1];
  return s;
}
